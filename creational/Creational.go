package main

import "fmt"

//Lets make a Cook

type Cook struct {
	recipe RecipeMaker
}

//Recipe

type Recipe struct {
	name string
	ingredients string
	timeTaken int
}

//RecipeMaker interface

type RecipeMaker interface {
	SetName() RecipeMaker
	SetIngredients() RecipeMaker
	GetRecipe() Recipe
}

//Espresso Time

type Espresso struct {
	Recipe
}
//For the Espresso e to return as RecipeMaker interface, Espresso must implement all the methods of RecipeMaker. This is the beauty of Go.
func (e *Espresso) SetName() RecipeMaker {
	e.Recipe.name = "Espresso"
	return e
}
func (e *Espresso) SetIngredients() RecipeMaker {
	e.Recipe.ingredients = "1 Shot of espresso in an espresso cup"
	return e
}
func (e *Espresso) GetRecipe() Recipe {
	return e.Recipe
}


//Let's make Cappuccino
type Cappuccino struct {
	Recipe
}
func (e *Cappuccino) SetName() RecipeMaker {
	e.Recipe.name = "Cappuccino"
	return e
}
func (e *Cappuccino) SetIngredients() RecipeMaker {
	e.Recipe.ingredients = "1 Shot of espresso, Steamed Milk, Milk Foam, Sprinkled Chocolate"
	return e
}
func (e *Cappuccino) GetRecipe() Recipe {
	return e.Recipe
}

//Now, it's time for a cup of Mocha
type Mocha struct {
	Recipe
}
func (e *Mocha) SetName() RecipeMaker {
	e.Recipe.name = "Mocha"
	return e
}
func (e *Mocha) SetIngredients() RecipeMaker {
	e.Recipe.ingredients = "1 Shot of espresso, 1 Spoon of Chocolate Powder, Steamed Milk, Sprinkled Chocolate"
	return e
}
func (e *Mocha) GetRecipe() Recipe {
	return e.Recipe
}

//We are almost done. Now that we've a Cook who can cook recipes, we need to implement some methods on Cook so that he can switch between them

//SetRecipe
//Struct that implements an interface can be return as that interface type

func (c *Cook) SetRecipe(r RecipeMaker) {
	c.recipe = r
}

//This is the part where the creational pattern plays its role.
func (c *Cook) CookIt() {
	c.recipe.SetName().SetIngredients()
	fmt.Println("Making a cup of", c.recipe.GetRecipe().name, " which contains ", c.recipe.GetRecipe().ingredients, "!")
}

//We are taking advantage of the fact that Struct can be returned as Interface if it implements all the methods of that interface
//Returning interfaces makes it possible to chain multiple commands


func main() {
	ChefRamsey := new(Cook)
	//Mocha gets a blank Recipe, its contents will be generated by our man, Chef Ramsey
	Mocha := Mocha{Recipe{}}
	ChefRamsey.SetRecipe(&Mocha)
	ChefRamsey.CookIt()

	//A cup of Cappuccino from Mr.Ramsey, bliss!!
	Cappuccino := Cappuccino{Recipe{}}
	ChefRamsey.SetRecipe(&Cappuccino)
	ChefRamsey.CookIt()

	//Mr.Ramsey, a shot of Espresso, please!!
	Espresso := Espresso{Recipe{}}
	ChefRamsey.SetRecipe(&Espresso)
	ChefRamsey.CookIt()

}